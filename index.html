<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEXUS - ÊåëÊà¶ËÄÖÁâπÂåñÂûãSNS</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #f0f4ff 0%, #e6f0ff 100%);
        }
        .nexus-bg {
            background: linear-gradient(135deg, #f0f4ff 0%, #e6f0ff 100%);
        }
        .nexus-card {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e0e7ff;
        }
        .nexus-button {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            border: none;
            transition: all 0.3s ease;
        }
        .nexus-button:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }
        .nexus-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .nexus-input {
            border: 2px solid #e0e7ff;
            background: rgba(255, 255, 255, 0.8);
            transition: all 0.3s ease;
        }
        .nexus-input:focus {
            border-color: #3b82f6;
            background: white;
            outline: none;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        .nexus-notification {
            background: #ef4444;
            color: white;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .nexus-tag {
            color: #3b82f6;
            font-weight: 500;
        }
        .nexus-phase {
            background: #dbeafe;
            color: #1e40af;
            border-left: 3px solid #3b82f6;
        }
        .nexus-like {
            color: #ef4444;
        }
        .message-bubble {
            animation: slideIn 0.3s ease;
        }
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .unread-indicator {
            background: #dbeafe;
            border-left: 3px solid #3b82f6;
        }
        .read-indicator {
            opacity: 0.6;
        }
        .place-card {
            background: linear-gradient(135deg, #f0f4ff 0%, #e0e7ff 100%);
            border-left: 4px solid #3b82f6;
            transition: all 0.3s ease;
        }
        .place-card:hover {
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
        }
        .coupon-badge {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }
        .location-marker {
            display: inline-block;
            width: 12px;
            height: 12px;
            background: #3b82f6;
            border-radius: 50%;
            margin-right: 4px;
        }
        .mbti-badge {
            background: #e0d4ff;
            color: #7c3aed;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: bold;
            margin-left: 4px;
        }
        .post-type-badge {
            background: #fecaca;
            color: #991b1b;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: bold;
        }
        .post-type-badge.business {
            background: #a7f3d0;
            color: #065f46;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const API_BASE = '';

        function NEXUS() {
            const [users, setUsers] = useState([]);
            const [posts, setPosts] = useState([]);
            const [messages, setMessages] = useState([]);
            const [groupChats, setGroupChats] = useState([]);
            const [locations, setLocations] = useState([]);
            const [places, setPlaces] = useState([]);
            const [currentUserId] = useState('user1');
            const [activeTab, setActiveTab] = useState('posts');
            const [messengerMode, setMessengerMode] = useState('dm');
            const [feedType, setFeedType] = useState('recommend');
            const [selectedTalk, setSelectedTalk] = useState(null);
            const [selectedGroupChat, setSelectedGroupChat] = useState(null);
            const [selectedProfile, setSelectedProfile] = useState(null);
            const [newPostContent, setNewPostContent] = useState('');
            const [newMessageContent, setNewMessageContent] = useState('');
            const [newGroupChatName, setNewGroupChatName] = useState('');
            const [searchQuery, setSearchQuery] = useState('');
            const [selectedLocation, setSelectedLocation] = useState(null);
            const [mbtiFilter, setMbtiFilter] = useState('all');
            const [loading, setLoading] = useState(true);
            const messagesEndRef = useRef(null);

            useEffect(() => {
                fetchData();
                const interval = setInterval(fetchData, 3000);
                return () => clearInterval(interval);
            }, []);

            useEffect(() => {
                scrollToBottom();
            }, [messages, selectedTalk, groupChats, selectedGroupChat]);

            const scrollToBottom = () => {
                messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
            };

            const fetchData = async () => {
                try {
                    const [usersRes, postsRes, messagesRes, groupChatsRes, locationsRes] = await Promise.all([
                        fetch(`${API_BASE}/api/users`),
                        fetch(`${API_BASE}/api/posts`),
                        fetch(`${API_BASE}/api/messages`),
                        fetch(`${API_BASE}/api/groupchats`),
                        fetch(`${API_BASE}/api/locations`)
                    ]);

                    const usersData = await usersRes.json();
                    const postsData = await postsRes.json();
                    const messagesData = await messagesRes.json();
                    const groupChatsData = await groupChatsRes.json();
                    const locationsData = await locationsRes.json();

                    setUsers(usersData);
                    setPosts(postsData);
                    setMessages(messagesData);
                    setGroupChats(groupChatsData);
                    setLocations(locationsData);
                    setLoading(false);
                } catch (error) {
                    console.error('Failed to fetch data:', error);
                    setLoading(false);
                }
            };

            const fetchPlaces = async (location) => {
                try {
                    const response = await fetch(`${API_BASE}/api/places/${encodeURIComponent(location)}`);
                    const data = await response.json();
                    setPlaces(data.places);
                    setSelectedLocation(location);
                } catch (error) {
                    console.error('Failed to fetch places:', error);
                }
            };

            const getCurrentUser = () => users.find(u => u.id === currentUserId);
            const getUserById = (id) => users.find(u => u.id === id);
            const getPostAuthor = (post) => getUserById(post.authorId);

            const getUnreadDMCount = () => {
                return messages.filter(m => m.recipientId === currentUserId && !m.isRead).length;
            };

            const getUnreadGroupCount = () => {
                return groupChats.reduce((count, gc) => {
                    return count + gc.messages.filter(m => m.recipientId === currentUserId && !m.isRead).length;
                }, 0);
            };

            const getTalks = () => {
                const talkMap = {};
                messages.forEach(msg => {
                    const otherId = msg.senderId === currentUserId ? msg.recipientId : msg.senderId;
                    if (!talkMap[otherId]) {
                        talkMap[otherId] = {
                            participantId: otherId,
                            messages: [],
                            lastMessage: '',
                            lastMessageTime: ''
                        };
                    }
                    talkMap[otherId].messages.push(msg);
                    talkMap[otherId].lastMessage = msg.message;
                    talkMap[otherId].lastMessageTime = msg.timestamp;
                });
                return Object.values(talkMap).sort((a, b) => new Date(b.lastMessageTime) - new Date(a.lastMessageTime));
            };

            const getTalkMessages = (participantId) => {
                return messages.filter(
                    m => (m.senderId === currentUserId && m.recipientId === participantId) ||
                         (m.senderId === participantId && m.recipientId === currentUserId)
                ).sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            };

            const getGroupChatMessages = (groupChatId) => {
                const groupChat = groupChats.find(g => g.id === groupChatId);
                return groupChat ? groupChat.messages : [];
            };

            const getSearchResults = () => {
                const query = searchQuery.toLowerCase();
                return posts.filter(post => {
                    const author = getPostAuthor(post);
                    return (
                        post.content.toLowerCase().includes(query) ||
                        author?.name.toLowerCase().includes(query) ||
                        author?.username.toLowerCase().includes(query) ||
                        post.hashtags?.some(tag => tag.toLowerCase().includes(query))
                    );
                });
            };

            const getFilteredPostsByMBTI = () => {
                const filtered = mbtiFilter === 'all' 
                    ? posts 
                    : posts.filter(p => {
                        const author = getPostAuthor(p);
                        return author?.mbti === mbtiFilter;
                    });
                
                if (feedType === 'following') {
                    const followingIds = getCurrentUser()?.following || [];
                    return filtered.filter(p => followingIds.includes(p.authorId));
                }
                return filtered;
            };

            const handleAddPost = async () => {
                if (newPostContent.trim()) {
                    try {
                        const currentUser = getCurrentUser();
                        const response = await fetch(`${API_BASE}/api/posts`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                authorId: currentUserId, 
                                content: newPostContent,
                                location: currentUser?.location,
                                postType: 'personal'
                            })
                        });
                        const newPost = await response.json();
                        setPosts([newPost, ...posts]);
                        setNewPostContent('');
                    } catch (error) {
                        console.error('Failed to create post:', error);
                    }
                }
            };

            const handleToggleLike = async (postId) => {
                try {
                    const response = await fetch(`${API_BASE}/api/posts/${postId}/like`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ userId: currentUserId })
                    });
                    const updatedPost = await response.json();
                    setPosts(posts.map(p => p.id === postId ? updatedPost : p));
                } catch (error) {
                    console.error('Failed to toggle like:', error);
                }
            };

            const handleFollowToggle = (userId) => {
                setUsers(users.map(u => {
                    if (u.id === currentUserId) {
                        return {
                            ...u,
                            following: u.following.includes(userId) 
                                ? u.following.filter(id => id !== userId)
                                : [...u.following, userId]
                        };
                    }
                    if (u.id === userId) {
                        return {
                            ...u,
                            followers: u.followers.includes(currentUserId)
                                ? u.followers.filter(id => id !== currentUserId)
                                : [...u.followers, currentUserId]
                        };
                    }
                    return u;
                }));
            };

            const handleSendMessage = async (recipientId) => {
                if (newMessageContent.trim()) {
                    try {
                        const response = await fetch(`${API_BASE}/api/messages`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ senderId: currentUserId, recipientId, message: newMessageContent })
                        });
                        const newMsg = await response.json();
                        setMessages([...messages, newMsg]);
                        setNewMessageContent('');
                        setTimeout(scrollToBottom, 100);
                    } catch (error) {
                        console.error('Failed to send message:', error);
                    }
                }
            };

            const handleSendGroupMessage = async (groupChatId) => {
                if (newMessageContent.trim()) {
                    try {
                        const response = await fetch(`${API_BASE}/api/groupchats/${groupChatId}/messages`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ senderId: currentUserId, content: newMessageContent })
                        });
                        const newMsg = await response.json();
                        setGroupChats(groupChats.map(gc => 
                            gc.id === groupChatId 
                                ? { ...gc, messages: [...gc.messages, newMsg] }
                                : gc
                        ));
                        setNewMessageContent('');
                        setTimeout(scrollToBottom, 100);
                    } catch (error) {
                        console.error('Failed to send group message:', error);
                    }
                }
            };

            const handleCreateGroupChat = async () => {
                if (newGroupChatName.trim()) {
                    try {
                        const response = await fetch(`${API_BASE}/api/groupchats`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                name: newGroupChatName,
                                members: [currentUserId]
                            })
                        });
                        const newGroupChat = await response.json();
                        setGroupChats([...groupChats, newGroupChat]);
                        setNewGroupChatName('');
                    } catch (error) {
                        console.error('Failed to create group chat:', error);
                    }
                }
            };

            const handleMarkAsRead = (participantId) => {
                setMessages(messages.map(m => {
                    if (m.recipientId === currentUserId && m.senderId === participantId && !m.isRead) {
                        return { ...m, isRead: true };
                    }
                    return m;
                }));
            };

            const formatTime = (timestamp) => {
                const date = new Date(timestamp);
                const now = new Date();
                const diff = now - date;
                const minutes = Math.floor(diff / 60000);
                const hours = Math.floor(diff / 3600000);
                const days = Math.floor(diff / 86400000);

                if (minutes < 1) return '‰ªä';
                if (minutes < 60) return `${minutes}ÂàÜÂâç`;
                if (hours < 24) return `${hours}ÊôÇÈñìÂâç`;
                if (days < 7) return `${days}Êó•Ââç`;
                return date.toLocaleDateString('ja-JP');
            };

            if (loading) {
                return (
                    <div className="flex items-center justify-center h-screen nexus-bg">
                        <div className="text-center">
                            <div className="text-4xl mb-4">üì±</div>
                            <p className="text-gray-600 text-lg">NEXUS Ë™≠Ëæº‰∏≠...</p>
                        </div>
                    </div>
                );
            }

            const currentUser = getCurrentUser();
            if (!currentUser) return <div className="text-center p-8">„É¶„Éº„Ç∂„Éº„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì</div>;

            const displayPosts = searchQuery ? getSearchResults() : getFilteredPostsByMBTI();
            const talks = getTalks();
